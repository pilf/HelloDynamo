l "lib/sanity.ex"
h l
c "lib/sanity.ex"
s = HelloDynamo.SanityServer.start_link
:gen_server.call s, :sanity
c "../sequence/lib/server.ex"
seq = Sequence.Server.start_link
seq = Sequence.Server.start_link 100
c "../sequence/lib/stash.ex"
stash = Sequence.Stash.start_link
stash = Sequence.Stash.start_link 200
seq = Sequence.Server.start_link seq
seq
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, :sanity
c "lib/access.ex"
pwd
c "lib/access.ex"
c "lib/hello_access.ex"
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, :sanity
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, :sanity
:gen_server.call pid, { :already_helloed, "Wonko" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
mix compile
!mix compile
help cmd
h cmd
h
r
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
r
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
Mix.Tasks.Compile.run nil
Mix.Tasks.Compile.run []
r
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
Mix.Tasks.Compile.run []
r
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Wonko" }
Amnesai.start
Amnesia.start
HelloDb.create
q = Exquisite.match PastSalutations, where: name == "input"
require Exquisite
q = Exquisite.match PastSalutations, where: name == "input"
use HelloDb
q = Exquisite.match PastSalutations, where: name == "input"
Amnesia.transaction do
{ _, matches, _ } = PastSalutations.select q |> Enum.count
end
Amnesia.transaction do: PastSalutations.select q
Amnesia.transaction! do
PastSalutations[name: 'Bob', number_of_hellows 5 ].write
end
Amnesia.transaction! do
PastSalutations[name: 'Bob', number_of_hellos 5 ].write
end
Amnesia.transaction! do
PastSalutations[name: 'Bob', number_of_hellos 5 ].write
end
Amnesia.transaction! do
PastSalutations[name: 'Bob', number_of_hellos: 5 ].write
end
{ _, matches, _ } = PastSalutations.select q |> Enum.count
Amnesia.transaction do: PastSalutations.select q
HelloDb.wait
Amnesia.transaction do: PastSalutations.select q
Amnesia.Schema.create
Amnesia.start
HelloDb.create
HelooDb.wait
HelloDb.wait
use Amnesia
use HelloDb
Amnesia.transaction do: PastSalutations.select q
q = Exquisite.match PastSalutations, where: name == "input"
Amnesia.transaction do: PastSalutations.select q
Amnesia.transaction do: PastSalutations.select q |> Enum.count
Exquisite.run q
Exquisite.run q, PastSalutations
q = Exquisite.match PastSalutations, where: name == "Bob"
Amnesia.transaction do
PastSalutations.select q
end
q
PastSalutations.read
PastSalutations.read("Bob")
PastSalutations.read!("Bob")
PastSalutations[name: "Philip", number_of_hellos 5 ].write
PastSalutations[name: "Philip", number_of_hellos: 5 ].write
Amnesia.transactions! do
PastSalutations[ name: "Philip", number_of_hellos: 10 ].write
end
Amnesia.transaction! do
PastSalutations[ name: "Philip", number_of_hellos: 10 ].write
end
PastSalutations.read!('Bob')
PastSalutations.read!('Philip')
Amnesia.Schema.create
Amnesia.start
HelloDb.create
HelloDb.wait
use Amnesia
require Exquisite
PastSalutations.read!('Bob')
HelloDb.wait
HelloDb.PastSalutations.read!('Bob')
use HelloDb
PastSalutations.read!('Bob')
PastSalutations.read!('Philip')
u = PastSalutations.read!('Philip')
u
Amnesia.start
HelloDb.wait
u = PastSalutations.read!('Philip')
u
Amnesia.transaction! do
PastSalutations[name: 'Bob', number_of_hellos: 20 ].write
end
u = PastSalutations.read!('Bob')
s = Exquisite.match PastSalutations, where: name == 'Bob'
Amnesia.transaction do: PastSalutations.select s
Amnesia.transaction do: PastSalutations.select s |> Enum.count
Amnesia.transaction do: PastSalutations.select s
{ _, m, _ } = Amnesia.transaction do: PastSalutations.select s
m |> Enum.count
s = Exquisite.match PastSalutations, where: name == 'Someonelse'
{ _, m, _ } = Amnesia.transaction do: PastSalutations.select s
d = Exquisite.match PastSalutations, where: name == 'Someonelse'
s = Exquisite.match PastSalutations, where: name == 'Bob'
{ _, m, _ } = Amnesia.transaction do: PastSalutations.select s
{ _, m, _ } = Amnesia.transaction do: PastSalutations.select d
HelloDynamo.Access.start_link
a = HelloDynamo.Access.start_link
:gen_server.call a, { :already_helloed, "Philip" }
a = HelloDynamo.Access.start_link
HelloDynamo.Access.run_already_helloed_query("Philip")
a = HelloDynamo.Access.start_link
HelloDynamo.Access.run_already_helloed_query("Philip")
HelloDynamo.Access.init
HelloDynamo.Access.init nil
HelloDynamo.Access.run_already_helloed_query("Philip")
HelloDb
HelloDynamo.Access.init nil
HelloDb
use HelloDb
HelloDynamo.Access.run_already_helloed_query("Phiip")
HelloDynamo.Access.init nil
HelloDynamo.Access.run_already_helloed_query("Phiip")
use HelloDb
HelloDynamo.Access.run_already_helloed_query("Phiip")
HelloDynamo.Access.init nil
HelloDynamo.Access.run_already_helloed_query("Phiip")
a = HelloDynamo.Access.start_link
:gen_server.call a, { :already_helloed, "Philip" }
matches = case HelloDynamo.Access.run_already_helloed_query("Philip") do
nil -> []
{ _, m, _ } -> m
end
ah? = matches 
ah? = matches |> Enum.count > 0
a = HelloDynamo.Access.start_link
:gen_server.call a, { :already_helloed, "Philip" }
a = HelloDynamo.Access.start_link
:gen_server.call a, { :already_helloed, "Philip" }
a = HelloDynamo.Access.start_link
:gen_server.call a, :sanity
a
{ :ok, b } = a
b
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, :sanity
:gen_server.call pid, { :already_helloed, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
HelloDynamo.Access.init nil
HelloDynamo.Access.handle_cast { :hello, "Philip" }, nil, nil
matches = case HelloDynamo.Access.run_already_helloed_query("Philip") do
nil -> []
{ _, m, _ } -> m
end
use HelloDb
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
use HelloDb
PastSalutations.read(pid)
PastSalutations.read
PastSalutations.read(self.id)
pid
PastSalutations.read(pid)
Amnesia.transaction do: PastSalutations.read(pid)
Amnesia.transaction! do: PastSalutations[ name: "Philip", number_of_hellos: 3 ].write
Amnesia.transaction do: PastSalutations.read(pid)
Amnesia.transaction! do: PastSalutations[ name: "Philip", number_of_hellos: 3 ].write(pid)
h (PastSalutations.write/0)
h (Amenisa.write/1)
h (Amenisa.write!/1)
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Philip" }
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Derrick" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
type "hello"
type("hello")
dir("hello")
h dir
h(dir/1)
require Kernal
Path.type "hello"
t "hello"
inspect "hello"
puts(inspect 5)
IO.puts(inspect 5)
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.call pid, { :already_helloed, "Philip" }
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
:gen_server.call pid, { :already_helloed, "Ra" }
:gen_server.cast pid, { :hello, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Ra" }
:gen_server.call pid, { :already_helloed, "Philip" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
:gen_server.call pid, { :already_helloed, "Ra" }
{ :ok, pid } = HelloDynamo.Access.start_link
:gen_server.cast pid, { :hello, "Philip" }
:gen_server.call pid, { :already_helloed, "Philip" }
:gen_server.call pid, { :already_helloed, "Ra" }
HelloDb.create
HelloDb.tables
user_home()
System.user_home
System.user
System.cwd
HelloDynamo.Access.start_link
HelloDynamo.Access.already_helloed "Philip"
HelloDynamo.Access.hello "Philip"
HelloDynamo.Access.already_helloed "Philip"
await
h await
h await/1
h await/4
type await
t await
t await/4
i await
await 1, 2, 3, 4
await 1, 2, 3
